package org.apache.pinot.core.segment.index.loader.defaultcolumn;

import com.google.common.base.Preconditions;
import java.io.File;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.configuration.PropertiesConfiguration;
import org.apache.pinot.core.data.function.FunctionEvaluator;
import org.apache.pinot.core.data.function.FunctionEvaluatorFactory;
import org.apache.pinot.core.data.readers.PinotSegmentRecordReader;
import org.apache.pinot.core.data.recordtransformer.CompositeTransformer;
import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;
import org.apache.pinot.core.segment.creator.ColumnIndexCreationInfo;
import org.apache.pinot.core.segment.creator.ColumnStatistics;
import org.apache.pinot.core.segment.creator.RecordReaderSegmentCreationDataSource;
import org.apache.pinot.core.segment.creator.SegmentIndexCreationInfo;
import org.apache.pinot.core.segment.creator.SegmentPreIndexStatsCollector;
import org.apache.pinot.core.segment.creator.StatsCollectorConfig;
import org.apache.pinot.core.segment.creator.TextIndexType;
import org.apache.pinot.core.segment.creator.impl.ColumnarIndexCreatorHelper;
import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;
import org.apache.pinot.core.segment.creator.impl.SegmentDictionaryCreator;
import org.apache.pinot.core.segment.creator.impl.V1Constants;
import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;
import org.apache.pinot.core.segment.index.loader.LoaderUtils;
import org.apache.pinot.core.segment.index.loader.V3RemoveIndexException;
import org.apache.pinot.core.segment.index.loader.V3UpdateIndexException;
import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;
import org.apache.pinot.core.segment.store.ColumnIndexType;
import org.apache.pinot.core.segment.store.SegmentDirectory;
import org.apache.pinot.spi.config.table.IngestionConfig;
import org.apache.pinot.spi.config.table.TableConfig;
import org.apache.pinot.spi.config.table.ingestion.TransformConfig;
import org.apache.pinot.spi.data.FieldSpec;
import org.apache.pinot.spi.data.Schema;
import org.apache.pinot.spi.data.readers.GenericRow;
import org.apache.pinot.spi.data.readers.RecordReader;
import org.apache.pinot.spi.utils.ByteArray;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class DerivedColumnHandler {

  private static final Logger LOGGER = LoggerFactory.getLogger(DerivedColumnHandler.class);

  private final File _indexDir;
  private final Schema _schema;
  private final TableConfig _tableConfig;
  private final SegmentMetadataImpl _segmentMetadata;
  private final int _totalDocs;
  private final SegmentDirectory.Writer _segmentWriter;
  private final IndexLoadingConfig _indexLoadingConfig;
  private final Map<String, TransformConfig> _columnToTransformConfig = new HashMap<>();
  private final SegmentGeneratorConfig _segmentGeneratorConfig;
  private final SegmentIndexCreationInfo _segmentIndexCreationInfo;

  private final PropertiesConfiguration _segmentProperties;

  protected DerivedColumnHandler(File indexDir, Schema schema, TableConfig tableConfig,
      SegmentMetadataImpl segmentMetadata, SegmentDirectory.Writer segmentWriter,
      IndexLoadingConfig indexLoadingConfig) {
    _indexDir = indexDir;
    _schema = schema;
    _segmentMetadata = segmentMetadata;
    _totalDocs = _segmentMetadata.getTotalDocs();
    _segmentWriter = segmentWriter;
    _indexLoadingConfig = indexLoadingConfig;
    _tableConfig = tableConfig;
    IngestionConfig ingestionConfig = _tableConfig.getIngestionConfig();
    if (ingestionConfig != null && ingestionConfig.getTransformConfigs() != null) {
      for (TransformConfig transformConfig : ingestionConfig.getTransformConfigs()) {
        _columnToTransformConfig.put(transformConfig.getColumnName(), transformConfig);
      }
    }
    _segmentProperties = SegmentMetadataImpl.getPropertiesConfiguration(indexDir);
    _segmentGeneratorConfig = new SegmentGeneratorConfig(_tableConfig, _schema);
    _segmentIndexCreationInfo = new SegmentIndexCreationInfo();
    _segmentIndexCreationInfo.setTotalDocs(_segmentMetadata.getTotalDocs());
  }

  public void updateDerivedColumn(String column, AutoGeneratedColumnHandler.ColumnAction action)
      throws Exception {

    LOGGER.info("Starting column action: {} on column: {}", action, column);

    // For V3 segment format, only support ADD action
    // For UPDATE and REMOVE action, throw exception to drop and re-download the segment
    if (action.isUpdateAction()) {
      throw new V3UpdateIndexException(
          "Derived value indices for column: " + column + " cannot be updated for V3 format segment.");
    }

    if (action.isRemoveAction()) {
      throw new V3RemoveIndexException(
          "Derived value indices for column: " + column + " cannot be removed for V3 format segment.");
    }

    FieldSpec derivedColumnFieldSpec = _schema.getFieldSpecFor(column);
    Preconditions.checkNotNull(derivedColumnFieldSpec);

    createDictionaryAndFwdIndex(derivedColumnFieldSpec);

    // Write index to V3 format.
    File dictionaryFile = new File(_indexDir, column + V1Constants.Dict.FILE_EXTENSION);
    File forwardIndexFile;
    if (derivedColumnFieldSpec.isSingleValueField()) {
      forwardIndexFile = new File(_indexDir, column + V1Constants.Indexes.SORTED_SV_FORWARD_INDEX_FILE_EXTENSION);
    } else {
      forwardIndexFile = new File(_indexDir, column + V1Constants.Indexes.UNSORTED_MV_FORWARD_INDEX_FILE_EXTENSION);
    }
    LoaderUtils.writeIndexToV3Format(_segmentWriter, column, dictionaryFile, ColumnIndexType.DICTIONARY);
    LoaderUtils.writeIndexToV3Format(_segmentWriter, column, forwardIndexFile, ColumnIndexType.FORWARD_INDEX);
  }

  private void createDictionaryAndFwdIndex(FieldSpec derivedColumnFieldSpec)
      throws Exception {

    String column = derivedColumnFieldSpec.getName();

    // Create new dictionary and forward index, and update column metadata
    ColumnStatistics columnProfile = getDerivedColumnStatistics(derivedColumnFieldSpec);
    Object defaultNullValue = derivedColumnFieldSpec.getDefaultNullValue();
    if (derivedColumnFieldSpec.getDataType() == FieldSpec.DataType.BYTES) {
      defaultNullValue = new ByteArray((byte[]) defaultNullValue);
    }
    ColumnIndexCreationInfo indexCreationInfo = new ColumnIndexCreationInfo(columnProfile, true/*createDictionary*/,
        _indexLoadingConfig.getVarLengthDictionaryColumns().contains(column), true/*isAutoGenerated*/,
        defaultNullValue);
    Map<String, ColumnIndexCreationInfo> indexCreationInfoMap = new HashMap<>();
    indexCreationInfoMap.put(column, indexCreationInfo);

    Schema derivedSchema = getDerivedColumnSchema(derivedColumnFieldSpec);
    ColumnarIndexCreatorHelper helper =
        new ColumnarIndexCreatorHelper(derivedSchema, _segmentGeneratorConfig, indexCreationInfoMap,
            Collections.emptySet(), Collections.emptySet(), _totalDocs, _indexDir);

    Schema argumentsSchema = getArgumentsSchema(derivedColumnFieldSpec);
    RecordReader segmentRecordReader = new PinotSegmentRecordReader(_indexDir, argumentsSchema, null);
    CompositeTransformer recordTransformer = CompositeTransformer.getDefaultTransformer(_tableConfig, argumentsSchema);
    GenericRow reuse = new GenericRow();
    while (segmentRecordReader.hasNext()) {
      reuse.clear();
      GenericRow next = segmentRecordReader.next(reuse);
      GenericRow transformedRow = recordTransformer.transform(next);
      Preconditions.checkState(transformedRow != null);
      helper.index(transformedRow);
    }

    // Add the column metadata information to the metadata properties.
    SegmentDictionaryCreator dictionaryCreator = helper.getDictionaryCreator(column);
    int dictionaryElementSize = (dictionaryCreator != null) ? dictionaryCreator.getNumBytesPerEntry() : 0;
    SegmentColumnarIndexCreator
        .addColumnMetadataInfo(_segmentProperties, column, indexCreationInfo, _totalDocs, derivedColumnFieldSpec,
            dictionaryCreator != null/*hasDictionary*/, dictionaryElementSize, true/*hasInvertedIndex*/,
            TextIndexType.NONE);
  }

  private ColumnStatistics getDerivedColumnStatistics(FieldSpec derivedColFieldSpec)
      throws Exception {
    String column = derivedColFieldSpec.getName();
    Schema argumentsSchema = getArgumentsSchema(derivedColFieldSpec);
    Schema derivedColumnSchema = getDerivedColumnSchema(derivedColFieldSpec);

    ColumnStatistics columnStatistics;
    try (RecordReader segmentRecordReader = new PinotSegmentRecordReader(_indexDir, argumentsSchema, null)) {
      RecordReaderSegmentCreationDataSource dataSource = new RecordReaderSegmentCreationDataSource(segmentRecordReader);
      SegmentPreIndexStatsCollector segmentStats =
          dataSource.gatherStats(new StatsCollectorConfig(_tableConfig, derivedColumnSchema, null));
      columnStatistics = segmentStats.getColumnProfileFor(column);
    } catch (Exception e) {
      LOGGER.error("Caught exception while collecting statistics for derived column: {}", column, e);
      throw e;
    }
    return columnStatistics;
  }

  private Schema getDerivedColumnSchema(FieldSpec derivedColumnFieldSpec) {
    Schema schema = new Schema();
    schema.addField(derivedColumnFieldSpec);
    return schema;
  }

  // todo function with no arguments - disallow it
  private Schema getArgumentsSchema(FieldSpec derivedColumnFieldSpec) {
    String column = derivedColumnFieldSpec.getName();
    TransformConfig transformConfig = _columnToTransformConfig.get(column);
    Preconditions.checkState(transformConfig != null && transformConfig.getTransformFunction() != null,
        "Must provide transform config for derived field: %s", column);
    FunctionEvaluator expressionEvaluator =
        FunctionEvaluatorFactory.getExpressionEvaluator(transformConfig.getTransformFunction());
    List<String> arguments = expressionEvaluator.getArguments();
    // We make 2 schemas, because PinotSegmentRecordReader does not accept columns which are not in segment schema,
    // and the new column is not in the segment schema
    Schema schema = new Schema();
    for (String argument : arguments) {
      FieldSpec argFieldSpec = _schema.getFieldSpecFor(argument);
      Preconditions.checkState(argFieldSpec != null);
      schema.addField(argFieldSpec);
    }
    return schema;
  }
}
